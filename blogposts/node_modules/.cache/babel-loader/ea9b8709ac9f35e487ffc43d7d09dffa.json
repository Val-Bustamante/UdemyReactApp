{"ast":null,"code":"//action creator\nimport _ from 'lodash';\nimport jsonPlaceholder from \"../api/jsonPlaceholder\"; // with async await, the action creator is not returning\n//a plain js object\n//without async though, the action will be dispatched to reducers\n//way before the request to the api is complete threfore not giving us access to data on time\n\nexport const fetchPosts = () => {\n  //no getState in arg because it is not being utilized\n  return async dispatch => {\n    //request to api\n    const response = await jsonPlaceholder.get('/posts'); //manually dispatching action\n\n    dispatch({\n      type: 'FETCH_POSTS',\n      payload: response.data\n    });\n  };\n};\nexport const fetchUser = id => async dispatch => {\n  const response = await jsonPlaceholder.get(`./users/${id}`);\n  dispatch({\n    type: 'FETCH_USER',\n    payload: response.data\n  });\n}; //only action creator that will be called\n\nexport const fetchPostsAndUsers = () => async (dispatch, getState) => {\n  //must dispatch the result of calling the action creator\n  //await = will make sure that when we dispatch the action creator\n  //and the inner func gets called, we wait for the api request to\n  //complete before doing anything else within this action creator\n  await dispatch(fetchPosts()); //using lolash map func, will create an array of all userids\n\n  const userIds = _.uniq(_.map(getState().posts, 'userId'));\n};\n/*export const fetchUser = (id) => (dispatch) => {\n    _fetchUser(id, dispatch);\n}\n\n//memoize outside the action creator so it only gets memoized one time\n//Where we will make a request and dispatch an action\n//fetches user one time\n// _ = private function that should not be accessed outside this file\nconst _fetchUser = _.memoize(async (id, dispatch) => {\n    const response = await jsonPlaceholder.get(`./users/${id}`)\n    dispatch({ type: 'FETCH_USER', payload: response.data })\n})*/","map":{"version":3,"sources":["/Users/valentinabustamante/Documents/UdemyReactApp/blogposts/src/actions/index.js"],"names":["_","jsonPlaceholder","fetchPosts","dispatch","response","get","type","payload","data","fetchUser","id","fetchPostsAndUsers","getState","userIds","uniq","map","posts"],"mappings":"AAAA;AACA,OAAOA,CAAP,MAAc,QAAd;AACA,OAAOC,eAAP,MAA4B,wBAA5B,C,CAEA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,UAAU,GAAG,MAAM;AAE5B;AACA,SAAO,MAAOC,QAAP,IAAoB;AAEvB;AACA,UAAMC,QAAQ,GAAG,MAAMH,eAAe,CAACI,GAAhB,CAAoB,QAApB,CAAvB,CAHuB,CAKvB;;AACAF,IAAAA,QAAQ,CAAC;AAAEG,MAAAA,IAAI,EAAE,aAAR;AAAuBC,MAAAA,OAAO,EAAEH,QAAQ,CAACI;AAAzC,KAAD,CAAR;AACH,GAPD;AAQH,CAXM;AAaP,OAAO,MAAMC,SAAS,GAAIC,EAAD,IAAQ,MAAOP,QAAP,IAAoB;AACjD,QAAMC,QAAQ,GAAG,MAAMH,eAAe,CAACI,GAAhB,CAAqB,WAAUK,EAAG,EAAlC,CAAvB;AACAP,EAAAA,QAAQ,CAAC;AAAEG,IAAAA,IAAI,EAAE,YAAR;AAAsBC,IAAAA,OAAO,EAAEH,QAAQ,CAACI;AAAxC,GAAD,CAAR;AACH,CAHM,C,CAKP;;AACA,OAAO,MAAMG,kBAAkB,GAAG,MAAM,OAAOR,QAAP,EAAiBS,QAAjB,KAA8B;AAElE;AACA;AACA;AACA;AACA,QAAMT,QAAQ,CAACD,UAAU,EAAX,CAAd,CANkE,CAQlE;;AACD,QAAMW,OAAO,GAAGb,CAAC,CAACc,IAAF,CAAOd,CAAC,CAACe,GAAF,CAAMH,QAAQ,GAAGI,KAAjB,EAAwB,QAAxB,CAAP,CAAhB;AAGF,CAZM;AAaP","sourcesContent":["//action creator\nimport _ from 'lodash';\nimport jsonPlaceholder from \"../api/jsonPlaceholder\"\n\n// with async await, the action creator is not returning\n//a plain js object\n//without async though, the action will be dispatched to reducers\n//way before the request to the api is complete threfore not giving us access to data on time\nexport const fetchPosts = () => {\n\n    //no getState in arg because it is not being utilized\n    return async (dispatch) => {\n\n        //request to api\n        const response = await jsonPlaceholder.get('/posts')\n\n        //manually dispatching action\n        dispatch({ type: 'FETCH_POSTS', payload: response.data })\n    }\n}\n\nexport const fetchUser = (id) => async (dispatch) => {\n    const response = await jsonPlaceholder.get(`./users/${id}`)\n    dispatch({ type: 'FETCH_USER', payload: response.data })\n}\n\n//only action creator that will be called\nexport const fetchPostsAndUsers = () => async (dispatch, getState) => {\n\n    //must dispatch the result of calling the action creator\n    //await = will make sure that when we dispatch the action creator\n    //and the inner func gets called, we wait for the api request to\n    //complete before doing anything else within this action creator\n    await dispatch(fetchPosts());\n\n    //using lolash map func, will create an array of all userids\n   const userIds = _.uniq(_.map(getState().posts, 'userId'));\n\n  \n}\n/*export const fetchUser = (id) => (dispatch) => {\n    _fetchUser(id, dispatch);\n}\n\n//memoize outside the action creator so it only gets memoized one time\n//Where we will make a request and dispatch an action\n//fetches user one time\n// _ = private function that should not be accessed outside this file\nconst _fetchUser = _.memoize(async (id, dispatch) => {\n    const response = await jsonPlaceholder.get(`./users/${id}`)\n    dispatch({ type: 'FETCH_USER', payload: response.data })\n})*/\n\n\n"]},"metadata":{},"sourceType":"module"}